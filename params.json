{"name":"ActionLogic","tagline":"Flexible and powerful business logic abstraction for teams of varying experience levels.","body":"# ActionLogic\r\n\r\n[![Build Status](https://travis-ci.org/rewinfrey/ActionLogic.svg?branch=master)](https://travis-ci.org/rewinfrey/ActionLogic)\r\n[![Gem Version](https://badge.fury.io/rb/action_logic.svg)](https://badge.fury.io/rb/action_logic)\r\n[![Code Climate](https://codeclimate.com/github/rewinfrey/action_logic/badges/gpa.svg)](https://codeclimate.com/github/rewinfrey/action_logic)\r\n[![coverage](https://codecov.io/github/rewinfrey/ActionLogic/coverage.svg?branch=master)](https://codecov.io/github/rewinfrey/ActionLogic?branch=master)\r\n[![Dependency Status](https://gemnasium.com/rewinfrey/action_logic.svg)](https://gemnasium.com/rewinfrey/action_logic)\r\n[![License](https://img.shields.io/badge/license-MIT-green.svg)](http://opensource.org/licenses/MIT)\r\n\r\n### Introduction\r\n\r\nThis is a business logic abstraction gem that provides structure to the organization and composition of business logic in a Ruby or Rails application. `ActionLogic` is inspired by gems like [ActiveInteraction](https://github.com/orgsync/active_interaction), [DecentExposure](https://github.com/hashrocket/decent_exposure), [Interactor](https://github.com/collectiveidea/interactor), [Light-Service](https://github.com/adomokos/light-service), [Mutations](https://github.com/cypriss/mutations), [Surrounded](https://github.com/saturnflyer/surrounded), [Trailblazer](https://github.com/apotonick/trailblazer) and [Wisper](https://github.com/krisleech/wisper).\r\n\r\nWhy another business logic abstraction gem? `ActionLogic` provides teams of various experience levels with a minimal yet powerful set of abstractions that promote easy to write and easy to understand code. By using `ActionLogic`, teams can more quickly and easily write business logic that honors the SOLID principles, is easy to test and easy to reason about, and provides a flexible foundation from which teams can model and define their application's business domains by focusing on reusable units of work that can be composed and validated with one another.\r\n\r\n### Contents\r\n\r\n* [Backstory](#backstory)\r\n* [Overview](#overview)\r\n* [`ActionContext`](#actioncontext)\r\n* [`ActionTask`](#actiontask)\r\n* [`ActionUseCase`](#actionusecase)\r\n* [`ActionCoordinator`](#actioncoordinator)\r\n* [Succeeding an `ActionContext`](#succeeding-an-actioncontext)\r\n* [Failing an `ActionContext`](#failing-an-actioncontext)\r\n* [Halting an `ActionContext`](#halting-an-actioncontext)\r\n* [Custom `ActionContext` Status](#custom-actioncontext)\r\n* [Error Handling](#error-handling)\r\n* [Attribute Validations](#attribute-validations)\r\n* [Type Validations](#type-validations)\r\n* [Custom Type Validations](#custom-type-validations)\r\n* [Presence Validations](#presence-validations)\r\n* [Custom Presence Validations](#custom-presence-validations)\r\n* [Before Validations](#before-validations)\r\n* [After Validations](#after-validations)\r\n* [Around Validations](#around-validations)\r\n* [Benchmarking](#benchmarking)\r\n\t* [Enable Benchmarking](#enable-benchmarking)\r\n\t* [Benchmark Logging](#benchmark-logging)\r\n\t* [Benchmark Log Formatting](#benchmark-log-formatting)\r\n\t* [Custom Benchmark Handling](#custom-benchmark-handling)\r\n* [Installation](#installation)\r\n* [Contributing](#contributing)\r\n\r\n### Backstory\r\n\r\nConsider a traditional e-commerce Rails application. Users can shop online and add items to their shopping cart until they are ready to check out.\r\nThe happy path scenario might go something like this: the user submits their order form, an orders controller action records the order in the database,\r\nsubmits the order total to a payment processor, waits for a response from the payment processor, and upon a success response from the payment processor sends\r\nan order confirmation email to the user, the order is sent internally to the warehouse for fulfillment which requires creating various records in the database,\r\nand finally the server responds to the initial POST request with a rendered html page including a message indicating the order was successfully processed. In this\r\nwork flow there are at least 7 distinct steps or tasks that must be satisfied in order for the application's business logic to be considered correct according\r\nto specifications.\r\n\r\nAlthough this flow works well for most users, there are other users whose credit card information might be expired or users who might attempt to check out when\r\nyour application's payment processor service is down. Additional edge case scenarios start to pop up in error logs as exception emails fill up your inbox.\r\nWhat happens when that user that is notorious for having 100 tabs open forgets to complete the checkout process and submits a two week old order form that\r\nincludes an item that your e-commerce store no longer stocks? What happens if an item is sold out? The edge cases and exception emails pile up, and as each one comes in\r\nyou add more and more logic to that controller action.\r\n\r\nWhat once was a simple controller action designed with only the happy path of a successful checkout in mind has now become 100 lines long with 5 to 10 levels\r\nof nested if statements. The voice of Uncle Bob starts ringing in your ears and you know there must be a better way. You think on it for awhile and consider not only\r\nthe technical challenges of refactoring this code, but you'd also like to make this code reusable and modular. You want this code to be easy to test and easy to maintain.\r\nYou want to honor the SOLID principles by writing classes that are singularly focused and easy to extend. You reason these new classes should only have to change if the\r\nbusiness logic they execute changes. You see that there are relationships between the entities and you see the possibility of abstractions that allow entities of similar types\r\nto interact nicely with each other. You begin thinking about interfaces and the Liskov Substitution Principle, and eventually your mind turns towards domains and data modeling.\r\nWhere does it end you wonder?\r\n\r\nBut you remember your team. It's a team of people all wanting to do their best, and represent a variety of backgrounds and experiences. Each person has varying degress of familiarity\r\nwith different types of abstractions and approaches, and you wonder what abstractions might be as easy to work with for a new developer as they are for an experienced developer?\r\nYou consider DSL's you've used in the past and wonder what is that ideal balance between magic and straightforward OOP design?\r\n\r\nAs more and more questions pile up in the empty space of your preferred text editor, you receive another exception email for a new problem with the order flow. The questions about\r\nhow to refactor this code transform into asking questions about how can you edit the existing code to add the new fix? Add a new nested if statement? You do what you can given the\r\nconstraints you're faced with, and add another 5 lines and another nested if statement. You realize there is not enough time to make this refactor happen, and you've got to push the\r\nfix out as soon as possible. Yet, as you merge your feature branch in master and deploy a hotfix, you think surely there must be a better way.\r\n\r\n`ActionLogic` was born from many hours thinking about these questions and considering how it might be possible to achieve a generic set of abstractions to help guide\r\nbusiness logic that would promote the SOLID principles and be easy for new and experienced developers to understand and extend. It's not a perfect abstraction (as nothing is),\r\nbut *can* help simplify your application's business logic by encouraging you to consider the smallest units of work required for your business logic while offering features\r\nlike type and presence validation that help reduce or eliminate boiler plate, defensive code (nil checks anyone?). However, as with all general purpose libraries, your mileage\r\nwill vary.\r\n\r\n### Overview\r\n\r\nThere are three levels of abstraction provided by `ActionLogic`:\r\n\r\n* [`ActionTask` (a concrete unit of work)](#action_task)\r\n* [`ActionUseCase` (organizes two or more `ActionTasks`)](#action_use_case)\r\n* [`ActionCoordinator` (coordinates two or more `ActionUseCases`)](#action_coordinator)\r\n\r\nEach level of abstraction operates with a shared, mutable data structure referred to as a `context` and is an instance of `ActionContext`. This shared `context` is threaded\r\nthrough each `ActionTask`, `ActionUseCase` and / or `ActionCoordinator` until all work is completed. The resulting `context` is returned to the original caller\r\n(typically in a Rails application this will be a controller action). In the problem described above we might have an `ActionUseCase` for organizing the checkout order flow,\r\nand each of the distinct steps would be represented by a separate `ActionTask`. However, overtime it may make more sense to split apart the singular `ActionUseCase` for the order\r\nflow into smaller `ActionUseCases` that are isolated by their domain (users, payment processor, inventory / warehouse, email, etc.). Considering that we limit our `ActionUseCases` to\r\nsingle domains, then the `ActionCoordinator` abstraction would allow us to coordinate communication between the `ActionUseCases` and their `ActionTasks` to fulfill the necessary\r\nwork required when a user submits a checkout order form.\r\n\r\nThe diagram below illustrates how the `ActionTask`, `ActionUseCase` and `ActionCoordinator` abstractions work together, and the role of `ActionContext` as the primary, single input:\r\n\r\n<img src=\"https://raw.githubusercontent.com/rewinfrey/action_logic/master/resources/overview_diagram.png\" />\r\n\r\n### ActionContext\r\n\r\nThe glue that binds the three layers of abstraction provided in `ActionLogic` is `ActionContext`. Anytime an `ActionTask`, `ActionUseCase` or `ActionCoordinator` is invoked\r\nan instance of `ActionContext` is created and passed as an input parameter to the receiving execution context. Because each of the three abstractions works in the same way\r\nwith `ActionContext`, it is intended to be a relatively simple \"learn once understand everywhere\" abstraction.\r\n\r\nInstances of `ActionContext` are always referred to within the body of `call` methods defined in any `ActionTask`, `ActionUseCase` or `ActionCoordinator` as `context`. An\r\ninstance of `ActionContext` is a thin wrapper around Ruby's standard library [`OpenStruct`](http://ruby-doc.org/stdlib-2.0.0/libdoc/ostruct/rdoc/OpenStruct.html). This allows\r\ninstances of `ActionContext` to be maximally flexible. Arbitrary attributes can be defined on a `context` and their values can be of any type.\r\n\r\nIn addition to allowing arbitrary attributes and values to be defined on a `context`, instances of `ActionContext` also conform to a set of simple rules:\r\n\r\n* Every `context` instance is instantiated with a default `status` of `:success`\r\n* A `context` responds to `success?` which returns true if the `status` is `:success`\r\n* A `context` responds to `fail!` which sets the `status` to `:failure`\r\n* A `context` responds to `fail?` which returns true if the `status` is `:failure`\r\n* A `context` rseponds to `halt!` which sets the `status` to `:halted`\r\n* A `context` responds to `halted?` which returns true if the `status` is `:halted`\r\n\r\nEnough with the words, let's look at some code! The following shows an instance of `ActionContext` and its various abilities:\r\n\r\n```ruby\r\ncontext = ActionLogic::ActionContext.new\r\n\r\ncontext # => #<ActionLogic::ActionContext status=:success>\r\n\r\n# default status is `:success`:\r\ncontext.status # => :success\r\n\r\n# defining a new attribute called `name` with the value `\"Example\"`:\r\ncontext.name = \"Example\"\r\n\r\n# retrieving the value of the `name` attribute:\r\ncontext.name # => \"Example\"\r\n\r\n# you can set attributes to anything, including Procs:\r\ncontext.lambda_example = -> { \"here\" }\r\n\r\ncontext.lambda_example # => #<Proc:0x007f8d6b0a9ba0@-:11 (lambda)>\r\n\r\ncontext.lambda_example.call # => \"here\"\r\n\r\n# contexts can be failed:\r\ncontext.fail!\r\n\r\ncontext.status # => :failure\r\n\r\ncontext.failure? # => true\r\n\r\n# contexts can also be halted:\r\ncontext.halt!\r\n\r\ncontext.status # => :halted\r\n\r\ncontext.halted? # => true\r\n```\r\n\r\nNow that we have seen what `ActionContext` can do, let's take a look at the lowest level of absraction in `ActionLogic` that consumes instances of `ActionContext`, the `ActionTask`\r\nabstraction.\r\n\r\n### ActionTask\r\n\r\nAt the core of every `ActionLogic` work flow is an `ActionTask`. These classes are the lowest level of abstraction in `ActionLogic` and are where concrete work is performed. All `ActionTasks` conform to the same structure and incorporate all features of `ActionLogic` including validations and error handling.\r\n\r\nTo implement an `ActionTask` class you must define a `call` method. You can also specify any before, after or around validations or an error handler. The following code example demonstrates an `ActionTask` class that includes before and after validations, and also demonstrates how an `ActionTask` is invoked :\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_before :expected_attribute1 => { :type => String },\r\n                   :expected_attribute2 => { :type => Fixnum, :presence => true }\r\n  validates_after  :example_attribute1 => { :type => String, :presence => ->(example_attribute1) { !example_attribute1.empty? } }\r\n\r\n  def call\r\n    # adds `example_attribute1` to the shared `context` with the value \"Example value\"\r\n    context.example_attribute1 = \"New value from context attributes: #{context.expected_attribute1} #{context.expected_attribute2}\"\r\n  end\r\nend\r\n\r\n# ActionTasks are invoked by calling an `execute` static method directly on the class with an optional hash of key value pairs:\r\nresult = ActionTaskExample.execute(:expected_attribute1 => \"example\", :expected_attribute2 => 123)\r\n\r\n# The result object is the shared context object (an instance of ActionContext):\r\nresult # => #<ActionLogic::ActionContext expected_attribute1=\"example\", expected_attribute2=123, status=:success, example_attribute1=\"New value from context attributes: example 123\">\r\n```\r\n\r\nThe `ActionTaskExample` is invoked using the static method `execute` which takes an optional hash of attributes that is converted into an `ActionContext`.\r\nAssuming the before validations are satisfied, the `call` method is invoked. In the body of the `call` method the `ActionTask` can access the shared `ActionContext`\r\ninstance via a `context` object. This shared `context` object allows for getting and setting attributes as needed. When the `call` method returns, the `context`\r\nis validated against any defined after validations, and the `context` is then returned to the caller.\r\n\r\nThe diagram below is a visual representation of how an `ActionTask` is evaluted when its `execute` method is invoked from a caller:\r\n\r\n<img src=\"https://raw.githubusercontent.com/rewinfrey/action_logic/master/resources/action_task_diagram.png\" />\r\n\r\nAlthough this example is for the `ActionTask` abstraction, `ActionUseCase` and `ActionCoordinator` follow the same pattern. The difference is that `ActionUseCase`\r\nis designed to organize multiple `ActionTasks`, and `ActionCoordinator` is designed to organize many `ActionUseCases`.\r\n\r\n### ActionUseCase\r\n\r\nAs business logic grows in complexity the number of steps or tasks required to fulfill that business logic tends to increase. Managing this complexity is a problem every team must face.\r\nAbstractions can help teams of varying experience levels work together and promote code that remains modular and simple to understand and extend. `ActionUseCase` represents a layer of\r\nabstraction that organizes multiple `ActionTasks` and executes each `ActionTask` in the order they are defined. Each task receives the same shared `context` so tasks can be composed together.\r\n\r\nTo implement an `ActionUseCase` class you must define a `call` method and a `tasks` method. You also can specify any before, after or around validations or an error handler.\r\nThe following is an example showcasing how an `ActionUseCase` class organizes the execution of multiple `ActionTasks` and defines before and after validations on the shared `context`:\r\n\r\n```ruby\r\nclass ActionUseCaseExample\r\n  include ActionLogic::ActionUseCase\r\n\r\n  validates_before :expected_attribute1 => { :type => String },\r\n                   :expected_attribute2 => { :type => Fixnum, :presence => true }\r\n  validates_after  :example_task1    => { :type => TrueClass, :presence => true },\r\n                   :example_task2    => { :type => TrueClass, :presence => true },\r\n                   :example_task3    => { :type => TrueClass, :presence => true },\r\n                   :example_usecase1 => { :type => TrueClass, :presence => true }\r\n\r\n  # The `call` method is invoked prior to invoking any of the ActionTasks defined by the `tasks` method.\r\n  # The purpose of the `call` method allows us to prepare the shared `context` prior to invoking the ActionTasks.\r\n  def call\r\n    context # => #<ActionLogic::ActionContext expected_attribute1=\"example\", expected_attribute2=123, status=:success>\r\n    context.example_usecase1 = true\r\n  end\r\n\r\n  def tasks\r\n    [ActionTaskExample1,\r\n     ActionTaskExample2,\r\n     ActionTaskExample3]\r\n  end\r\nend\r\n\r\nclass ActionTaskExample1\r\n  include ActionLogic::ActionTask\r\n  validates_after :example_task1 => { :type => TrueClass, :presence => true }\r\n\r\n  def call\r\n    context # => #<ActionLogic::ActionContext expected_attribute1=\"example\", expected_attribute2=123, status=:success, example_usecase1=true>\r\n    context.example_task1 = true\r\n  end\r\nend\r\n\r\nclass ActionTaskExample2\r\n  include ActionLogic::ActionTask\r\n  validates_after :example_task2 => { :type => TrueClass, :presence => true }\r\n\r\n  def call\r\n    context # => #<ActionLogic::ActionContext expected_attribute1=\"example\", expected_attribute2=123, status=:success, example_usecase1=true, example_task1=true>\r\n    context.example_task2 = true\r\n  end\r\nend\r\n\r\nclass ActionTaskExample3\r\n  include ActionLogic::ActionTask\r\n  validates_after :example_task3 => { :type => TrueClass, :presence => true }\r\n\r\n  def call\r\n    context # => #<ActionLogic::ActionContext expected_attribute1=\"example\", expected_attribute2=123, status=:success, example_usecase1=true, example_task1=true, example_task2=true>\r\n    context.example_task3 = true\r\n  end\r\nend\r\n\r\n# To invoke the ActionUseCaseExample, we call its execute method with the required attributes:\r\nresult = ActionUseCaseExample.execute(:expected_attribute1 => \"example\", :expected_attribute2 => 123)\r\n\r\nresult # => #<ActionLogic::ActionContext expected_attribute1=\"example\", expected_attribute2=123, status=:success, example_usecase1=true, example_task1=true, example_task2=true, example_task3=true>\r\n```\r\n\r\nBy following the value of the shared `context` from the `ActionUseCaseExample` to each of the `ActionTask` classes, it is possible to see how the shared `context`\r\nis mutated to accomodate the various attributes and their values each execution context adds to the `context`. It also reveals the order in which the `ActionTasks`\r\nare evaluated, and indicates that the `call` method of the `ActionUseCaseExample` is invoked prior to any of the `ActionTasks` defined in the `tasks` method.\r\n\r\nTo help visualize the flow of execution when an `ActionUseCase` is invoked, this diagram aims to illustrate the relationship between `ActionUseCase` and `ActionTasks`\r\nand the order in which operations are performed:\r\n\r\n<img src=\"https://raw.githubusercontent.com/rewinfrey/action_logic/master/resources/action_use_case_diagram.png\" />\r\n\r\n### ActionCoordinator\r\n\r\nSometimes the behavior we wish our Ruby or Rails application to provide requires us to coordinate work between various domains of our application's business logic.\r\nThe `ActionCoordinator` abstraction is intended to help coordinate multiple `ActionUseCases` by allowing you to define a plan of which `ActionUseCases` to invoke\r\ndepending on the outcome of each `ActionUseCase` execution. The `ActionCoordinator` abstraction is the highest level of abstraction in `ActionLogic`.\r\n\r\nTo implement an `ActionCoordinator` class, you must define a `call` method in addition to a `plan` method. The purpose of the `plan` method is to define a state\r\ntransition map that links together the various `ActionUseCase` classes the `ActionCoordinator` is organizing, as well as allowing you to define error or halt\r\nscenarios based on the result of each `ActionUseCase`. The following code example demonstrates a simple `ActionCoordinator`:\r\n\r\n```ruby\r\nclass ActionCoordinatorExample\r\n  include ActionLogic::ActionCoordinator\r\n\r\n  def call\r\n    context.required_attribute1 = \"required attribute 1\"\r\n    context.required_attribute2 = \"required attribute 2\"\r\n  end\r\n\r\n  def plan\r\n    {\r\n      ActionUseCaseExample1 => { :success => ActionUseCaseExample2,\r\n                                 :failure => ActionUseCaseFailureExample },\r\n      ActionUseCaseExample2 => { :success => nil,\r\n                                 :failure => ActionUseCaseFailureExample },\r\n      ActionUseCaseFailureExample => { :success => nil }\r\n    }\r\n  end\r\nend\r\n\r\nclass ActionUseCaseExample1\r\n  include ActionLogic::ActionUseCase\r\n\r\n  validates_before :required_attribute1 => { :type => String }\r\n\r\n  def call\r\n    context # => #<ActionLogic::ActionContext status=:success, required_attribute1=\"required attribute 1\", required_attribute2=\"required attribute 2\">\r\n    context.example_usecase1 = true\r\n  end\r\n\r\n  # Normally `tasks` would define multiple tasks, but in this example, I've used one ActionTask to keep the overall code example smaller\r\n  def tasks\r\n    [ActionTaskExample1]\r\n  end\r\nend\r\n\r\nclass ActionUseCaseExample2\r\n  include ActionLogic::ActionUseCase\r\n\r\n  validates_before :required_attribute2 => { :type => String }\r\n\r\n  def call\r\n    context # => #<ActionLogic::ActionContext status=:success, required_attribute1=\"required attribute 1\", required_attribute2=\"required attribute 2\", example_usecase1=true, example_task1=true>\r\n    context.example_usecase2 = true\r\n  end\r\n\r\n  # Normally `tasks` would define multiple tasks, but in this example, I've used one ActionTask to keep the overall code example smaller\r\n  def tasks\r\n    [ActionTaskExample2]\r\n  end\r\nend\r\n\r\n# In this example, we are not calling ActionUseCaseFailureExample, but is used to illustrate the purpose of the `plan` of our ActionCoordinator\r\n# in the event of a failure in one of the consumed `ActionUseCases`\r\nclass ActionUseCaseFailureExample\r\n  include ActionLogic::ActionUseCase\r\n\r\n  def call\r\n  end\r\n\r\n  def tasks\r\n    [ActionTaskLogFailure,\r\n     ActionTaskEmailFailure]\r\n  end\r\nend\r\n\r\nclass ActionTaskExample1\r\n  include ActionLogic::ActionTask\r\n  validates_after :example_task1 => { :type => TrueClass, :presence => true }\r\n\r\n  def call\r\n    context # => #<ActionLogic::ActionContext status=:success, required_attribute1=\"required attribute 1\", required_attribute2=\"required attribute 2\", example_usecase1=true>\r\n    context.example_task1 = true\r\n  end\r\nend\r\n\r\nclass ActionTaskExample2\r\n  include ActionLogic::ActionTask\r\n  validates_after :example_task2 => { :type => TrueClass, :presence => true }\r\n\r\n  def call\r\n    context # => #<ActionLogic::ActionContext status=:success, required_attribute1=\"required attribute 1\", required_attribute2=\"required attribute 2\", example_usecase1=true, example_task1=true, example_usecase2=true>\r\n    context.example_task2 = true\r\n  end\r\nend\r\n\r\nresult = ActionCoordinatorExample.execute\r\n\r\nresult # => #<ActionLogic::ActionContext status=:success, required_attribute1=\"required attribute 1\", required_attribute2=\"required attribute 2\", example_usecase1=true, example_task1=true, example_usecase2=true, example_task2=true>\r\n```\r\n\r\n<img src=\"https://raw.githubusercontent.com/rewinfrey/action_logic/master/resources/action_coordinator_diagram.png\" />\r\n\r\n### Succeeding an `ActionContext`\r\nBy default, the value of the `status` attribute of instances of `ActionContext` is `:success`. Normally this is useful information for the caller of an `ActionTask`,\r\n`ActionUseCase` or `ActionCoordinator` because it informs the caller that the various execution context(s) were successful. In other words, a `:success` status\r\nindicates that none of the execution contexts had a failure or halted execution.\r\n\r\n### Failing an `ActionContext`\r\nUsing `context.fail!` does two important things: it immediately stops the execution of any proceeding business logic (prevents any additional `ActionTasks` from executing)\r\nand also sets the status of the `context` as `:failure`. This status is most applicable to the caller or an `ActionCoordinator` that might have a plan specifically for a `:failure`\r\nstatus of a resulting `ActionUseCase`.\r\n\r\nThe following is a simple example to show how a `context` is failed within a `call` method:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  def call\r\n    if failure_condition?\r\n      context.fail!\r\n    end\r\n  end\r\n\r\n  def failure_condition?\r\n    true\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute\r\n\r\nresult # => #<ActionLogic::ActionContext status=:failure, message=\"\">\r\n```\r\n\r\nWhen failing a `context` it is possible to also specify a message:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  def call\r\n    if failure_condition?\r\n      context.fail! \"Something was invalid\"\r\n    end\r\n  end\r\n\r\n  def failure_condition?\r\n    true\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute\r\n\r\nresult # => #<ActionLogic::ActionContext status=:failure, message=\"Something was invalid\">\r\n\r\nresult.message # => \"Something was invalid\"\r\n```\r\n\r\nFrom the above example we see how it is possible to `fail!` a `context` while also specifying a clarifying message about the failure condition. Later, we retrieve\r\nthat failure message via the `message` attribute defined on the returned `context`.\r\n\r\n### Halting an `ActionContext`\r\nLike, failing a context, Using `context.halt!` does two important things: it immediately halts the execution of any proceeding business logic (prevents any additional `ActionTasks`\r\nfrom executing) and also sets the status of the `context` as `:halted`. The caller may use that information to define branching logic or an `ActionCoordinator` may use that\r\ninformation as part of its `plan`.\r\n\r\nHowever, unlike failing a `context`, halting is designed to indicate that no more processing is required, but otherwise execution was successful.\r\n\r\nThe following is a simple example to show how a `context` is halted within a `call` method:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  def call\r\n    if halt_condition?\r\n      context.halt!\r\n    end\r\n  end\r\n\r\n  def halt_condition?\r\n    true\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute\r\n\r\nresult # => #<ActionLogic::ActionContext status=:halted, message=\"\">\r\n```\r\n\r\nWhen failing a `context` it is possible to also specify a message:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  def call\r\n    if halt_condition?\r\n      context.halt! \"Something required a halt\"\r\n    end\r\n  end\r\n\r\n  def halt_condition?\r\n    true\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute\r\n\r\nresult # => #<ActionLogic::ActionContext status=:halted, message=\"Something required a halt\">\r\n\r\nresult.message # => \"Something required a halt\"\r\n```\r\n\r\nFrom the above example we see how it is possible to `halt!` a `context` while also specifying a clarifying message about the halt condition. Later, we retrieve\r\nthat halt message via the `message` attribute defined on the returned `context`.\r\n\r\n### Custom `ActionContext` Status\r\nIt is worthwhile to point out that you should not feel limited to only using the three provided statuses of `:success`, `:failure` or `:halted`. It is easy to implement your\r\nown system of statuses if you prefer. For example, consider a system that is used to defining various status codes or disposition codes to indicate the result of some business\r\nlogic. Instances of `ActionContext` can be leveraged to indicate these disposition codes by using the `status` attribute, or by defining custom attributes. You are encouraged\r\nto expirement and play with the flexibility provided to you by `ActionContext` in determining what is optimal for your given code contexts and your team.\r\n\r\n```ruby\r\nclass RailsControllerExample < ApplicationController\r\n  def create\r\n    case create_use_case.status\r\n      when :disposition_1 then ActionUseCaseSuccess1.execute(create_use_case)\r\n      when :disposition_2 then ActionUseCaseSuccess2.execute(create_use_case)\r\n      when :disposition_9 then ActionUseCaseFailure.execute(create_use_case)\r\n      else\r\n        ActionUseCaseDefault.execute(create_use_case)\r\n    end\r\n  end\r\n\r\n  private\r\n\r\n  def create_use_case\r\n    @create_use_case ||= ActionUseCaseExample.execute(params)\r\n  end\r\nend\r\n```\r\n\r\nAlthough this contrived example would be ideal for an `ActionCoordinator` (because the result of `ActionUseCaseExample` drives the execution of the next `ActionUseCase`), this\r\nexample serves to show that `status` can be used with custom disposition codes to drive branching behavior.\r\n\r\n### Error Handling\r\nDuring execution of an `ActionTask`, `ActionUseCase` or `ActionCoordinator` you may wish to define custom behavior for handling errors. Within any of these classes\r\nyou can define an `error` method that receives as its input the error exception. Invoking an `error` method does not make any assumptions about the `status` of the\r\nunderlying `context`. Execution of the `ActionTask`, `ActionUseCase` or `ActionCoordinator` also stops after the `error` method returns, and execution of the work\r\nflow continues as normal unless the `context` is failed or halted.\r\n\r\nThe following example is a simple illustration of how an `error` method is invoked for an `ActionTask`:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  def call\r\n    context.before_raise = true\r\n    raise \"Something broke\"\r\n    context.after_raise = true\r\n  end\r\n\r\n  def error(e)\r\n    context.error = \"the error is passed in as an input parameter: #{e.class}\"\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute\r\n\r\n# the status of the context is not mutated\r\nresult.status # => :success\r\n\r\nresult.error # => \"the error is passed in as an input parameter: RuntimeError\"\r\n\r\nresult.before_raise # => true\r\n\r\nresult.after_raise # => nil\r\n```\r\n\r\nIt is important to note that defining an `error` method is **not** required. If at any point in the execution of an `ActionTask`, `ActionUseCase` or `ActionCoordinator`\r\nan uncaught exception is thrown **and** an `error` method is **not** defined, the exception is raised to the caller.\r\n\r\n### Attribute Validations\r\nThe most simple and basic type of validation offered by `ActionLogic` is attribute validation. To require that an attribute be defined on an instance of `ActionContext`, you\r\nneed only specify the name of the attribute and an empty hash with one of the three validation types (before, after or around):\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_before :required_attribute1 => {}\r\n\r\n  def call\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute(:required_attribute1 => true)\r\n\r\nresult.status # => :success\r\n\r\nresult.required_attribute1 # => true\r\n```\r\n\r\nHowever, in the above example, if we were to invoke the `ActionTaskExample` without the `required_attribute1` parameter, the before validation would fail and raise\r\nan `ActionLogic::MissingAttributeError` and also detail which attribute is missing:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_before :required_attribute1 => {}\r\n\r\n  def call\r\n  end\r\nend\r\n\r\nActionTaskExample.execute # ~> context: ActionTaskExample message: [:required_attribute1] (ActionLogic::MissingAttributeError)\r\n```\r\n\r\nAttribute validations are defined in the same way regardless of the timing of the validation ([before](#before-validations), [after](#after-validations) or\r\n[around](#around-validations)). Please refer to the relevant sections for examples of their usage.\r\n\r\n### Type Validations\r\nIn addition to attribute validations, `ActionLogic` also allows you to validate against the type of the value of the attribute you expect to be defined in an instance\r\nof `ActionContext`. To understand the default types `ActionLogic` validates against, please see the following example:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_after :integer_test => { :type => Fixnum },\r\n                  :float_test   => { :type => Float },\r\n                  :string_test  => { :type => String },\r\n                  :truthy_test  => { :type => TrueClass },\r\n                  :falsey_test  => { :type => FalseClass },\r\n                  :hash_test    => { :type => Hash },\r\n                  :array_test   => { :type => Array },\r\n                  :symbol_test  => { :type => Symbol },\r\n                  :nil_test     => { :type => NilClass }\r\n\r\n  def call\r\n    context.integer_test = 123\r\n    context.float_test   = 1.0\r\n    context.string_test  = \"test\"\r\n    context.truthy_test  = true\r\n    context.falsey_test  = false\r\n    context.hash_test    = {}\r\n    context.array_test   = []\r\n    context.symbol_test  = :symbol\r\n    context.nil_test     = nil\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute\r\n\r\nresult # => #<ActionLogic::ActionContext status=:success,\r\n            #                            integer_test=123,\r\n            #                            float_test=1.0,\r\n            #                            string_test=\"test\",\r\n            #                            truthy_test=true,\r\n            #                            falsey_test=false,\r\n            #                            hash_test={},\r\n            #                            array_test=[],\r\n            #                            symbol_test=:symbol,\r\n            #                            nil_test=nil>\r\n```\r\n\r\nIt's important to point out that Ruby's `true` and `false` are not `Boolean` but `TrueClass` and `FalseClass` respectively. Additionally, `nil`'s type is `NilClass` in Ruby.\r\nAlso potentially surprising to some is that Ruby's integer type is of class `Fixnum`, but floats are of class `Float`.\r\n\r\nAs we saw with attribute validations, if an attribute's value does not conform to the type expected, `ActionLogic` will raise an `ActionLogic::AttributeTypeError`\r\nwith a detailed description about which attribute's value failed the validation:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_after :integer_test => { :type => Fixnum }\r\n\r\n  def call\r\n    context.integer_test = 1.0\r\n  end\r\nend\r\n\r\nActionTaskExample.execute # ~> context: ActionTaskExample message: Attribute: integer_test with value: 1.0 was expected to be of type Fixnum but is Float (ActionLogic::AttributeTypeError)\r\n```\r\n\r\nIn addition to the above default types it is possible to also validate against user defined types.\r\n\r\n### Custom Type Validations\r\nIf you would like to validate the type of attributes on a given `context` with your application's classes, `ActionLogic` is happy to provide that functionality.\r\n\r\nLet's consider the following example:\r\n\r\n```ruby\r\nclass ExampleClass\r\nend\r\n\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_after :example_attribute => { :type => ExampleClass }\r\n\r\n  def call\r\n    context.example_attribute = ExampleClass.new\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute\r\n\r\nresult # => #<ActionLogic::ActionContext status=:success, example_attribute=#<ExampleClass:0x007f95d1922bd8>>\r\n```\r\n\r\nIn the above example, a custom class `ExampleClass` is defined. In order to type validate against this class, the required format for the name of the class is simply\r\nthe class constant `ExampleClass`.\r\n\r\nIf a custom type validation fails, `ActionLogic` provides the same `ActionLogic::AttributeTypeError` with a detailed explanation about what attribute is in violation\r\nof the type validation:\r\n\r\n```ruby\r\nclass ExampleClass\r\nend\r\n\r\nclass OtherClass\r\nend\r\n\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_after :example_attribute => { :type => ExampleClass }\r\n\r\n  def call\r\n    context.example_attribute = OtherClass.new\r\n  end\r\nend\r\n\r\nActionTaskExample.execute # ~> context: ActionTaskExample message: Attribute: example_attribute with value: #<OtherClass:0x007fb5ca04edb8> was expected to be of type ExampleClass but is OtherClass (ActionLogic::AttributeTypeError)\r\n```\r\n\r\nAttribute and type validations are very helpful, but in some situations this is not enough. Additionally, `ActionLogic` provides presence validation so you can also verify that\r\na given attribute on a context not only has the correct type, but also has a value that is considered `present`.\r\n\r\n### Presence Validations\r\n\r\n`ActionLogic` also allows for presence validation for any attribute on an instance of `ActionContext`. Like other validations, presence validations can be specified in before, after or\r\naround validations.\r\n\r\nBy default, presence validations simply check to determine if an attribute's value is not `nil` or is not `false`. To define a presence validation, you need only specify `:presence => true`\r\nfor the attribute you wish to validate against:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_before :example_attribute => { :presence => true }\r\n\r\n  def call\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute(:example_attribute => 123)\r\n\r\nresult # => #<ActionLogic::ActionContext example_attribute=123, status=:success>\r\n```\r\n\r\nHowever, if a presence validation fails, `ActionLogic` will raise an `ActionLogic::PresenceError` with a detailed description about the attribute failing the presence validation\r\nand why:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_before :example_attribute => { :presence => true }\r\n\r\n  def call\r\n  end\r\nend\r\n\r\nActionTaskExample.execute(:example_attribute => nil) # ~> context: ActionTaskExample message: Attribute: example_attribute is missing value in context but presence validation was specified (ActionLogic::PresenceError)\r\n```\r\n\r\n### Custom Presence Validations\r\n\r\nSometimes when wanting to validate presence of an attribute with an aggregate type (like `Array` or `Hash`), we may want to validate that such a type is not empty. If\r\nyou wish to validate presence for a type that requires inspecting the value of the attribute, `ActionLogic` allows you the ability to define a custom `Proc` to validate\r\nan attribute's value against.\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_before :example_attribute => { :presence => ->(attribute) { attribute.any? } }\r\n\r\n  def call\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute(:example_attribute => [\"element1\", \"element2\", \"element3\"])\r\n\r\nresult # => #<ActionLogic::ActionContext example_attribute=[\"element1\", \"element2\", \"element3\"], status=:success>\r\n```\r\n\r\nIn the example above, we define a lambda that accepts as input the value of the attribute on the `context`. In this case, we are interested in verifying that\r\n`example_attribute` is not an empty `Array` or an empty `Hash`. This passes our before validation because `ActionTaskExample` is invoked with an `example_attribute`\r\nwhose value is an array consisting of three elements.\r\n\r\nHowever, if a custom presence validation fails, `ActionLogic` will raise an `ActionLogic::PresenceError` with a detailed description about the attribute failing\r\nthe custom presence validation:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_before :example_attribute => { :presence => ->(attribute) { attribute.any? } }\r\n\r\n  def call\r\n  end\r\nend\r\n\r\nActionTaskExample.execute(:example_attribute => []) # ~> context: ActionTaskExample message: Attribute: example_attribute is missing value in context but custom presence validation was specified (ActionLogic::PresenceError)\r\n```\r\n\r\nIn the above example, we have failed to pass the presence validation for `example_attribute` because the value of `example_attribute` is an empty array. When\r\nthe custom presence validation lambda is called, the lambda returns `false` and the `ActionLogic::PresenceError` is thrown, with an error message indicating\r\nthe attribute that failed the presence validation while also indicating that a custom presence validation was specified.\r\n\r\n### Before Validations\r\n\r\nIf you combine Rails ActionController's `before_filter` and ActiveModel's `validates` then you have approximately what `ActionLogic` defines as `validates_before`.\r\nBefore validations can be defined in any of the `ActionLogic` abstractions (`ActionTask`, `ActionUseCase` and `ActionCoordinator`). In each abstraction a `validates_before`\r\noperation is performed *before* invoking the `call` method.\r\n\r\nBefore validations allow you to specify a required attribute and optionally its type and / or presence. The following example illustrates how to specify a before\r\nvalidation on a single attribute:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_before :example_attribute => { :type => Array, :presence => ->(attribute) { attribute.any? } }\r\n\r\n  def call\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute(:example_attribute => [1, 2, 3])\r\n\r\nresult # => #<ActionLogic::ActionContext example_attribute=[1, 2, 3], status=:success>\r\n```\r\n\r\nThe following example illustrates how to specify a before validation for multiple attributes:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_before :example_attribute => { :type => Array, :presence => ->(attribute) { attribute.any? } },\r\n                   :example_attribute2 => { :type => Fixnum }\r\n\r\n  def call\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute(:example_attribute => [1, 2, 3], :example_attribute2 => 1)\r\n\r\nresult # => #<ActionLogic::ActionContext example_attribute=[1, 2, 3], example_attribute2=1, status=:success>\r\n```\r\n\r\n### After Validations\r\n\r\nIf you combine Rails ActionController's `after_filter` and ActiveModel's `validates` then you have approximately what `ActionLogic` defines as `validates_after`.\r\nAfter validations can be defined in any of the `ActionLogic` abstractions (`ActionTask`, `ActionUseCase` and `ActionCoordinator`). In each abstraction a `validates_after`\r\noperation is performed *after* invoking the `call` method.\r\n\r\nAfter validations allow you to specify a required attribute and optionally its type and / or presence. The following example illustrates how to specify an after\r\nvalidation on a single attribute:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_after :example_attribute => { :type => Array, :presence => ->(attribute) { attribute.any? } }\r\n\r\n  def call\r\n    context.example_attribute = [1, 2, 3]\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute\r\n\r\nresult # => #<ActionLogic::ActionContext example_attribute=[1, 2, 3], status=:success>\r\n```\r\nThe following example illustrates how to specify an after validation for multiple attributes:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_after :example_attribute => { :type => Array, :presence => ->(attribute) { attribute.any? } },\r\n                  :example_attribute2 => { :type => Fixnum }\r\n\r\n  def call\r\n    context.example_attribute = [1, 2, 3]\r\n    context.example_attribute2 = 1\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute\r\n\r\nresult # => #<ActionLogic::ActionContext example_attribute=[1, 2, 3], example_attribute2=1, status=:success>\r\n```\r\n\r\n### Around Validations\r\n\r\nIf you combine Rails ActionController's `around_filter` and ActiveModel's `validates` then you have approximately what `ActionLogic` defines as `validates_around`.\r\nAround validations can be defined in any of the `ActionLogic` abstractions (`ActionTask`, `ActionUseCase` and `ActionCoordinator`). In each abstraction a `validates_around`\r\noperation is performed *before* and *after* invoking the `call` method.\r\n\r\nAround validations allow you to specify a required attribute and optionally its type and / or presence. The following example illustrates how to specify an around\r\nvalidation on a single attribute:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_around :example_attribute => { :type => Array, :presence => ->(attribute) { attribute.any? } }\r\n\r\n  def call\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute(:example_attribute => [1, 2, 3])\r\n\r\nresult # => #<ActionLogic::ActionContext example_attribute=[1, 2, 3], status=:success>\r\n```\r\nThe following example illustrates how to specify an around validation for multiple attributes:\r\n\r\n```ruby\r\nclass ActionTaskExample\r\n  include ActionLogic::ActionTask\r\n\r\n  validates_around :example_attribute => { :type => Array, :presence => ->(attribute) { attribute.any? } },\r\n                   :example_attribute2 => { :type => Fixnum }\r\n\r\n  def call\r\n  end\r\nend\r\n\r\nresult = ActionTaskExample.execute(:example_attribute => [1, 2, 3], :example_attribute2 => 1)\r\n\r\nresult # => #<ActionLogic::ActionContext example_attribute=[1, 2, 3], example_attribute2=1, status=:success>\r\n```\r\n\r\n### Benchmarking\r\n\r\nAt some point you may want to benchmark and profile the performance of your code. `ActionLogic` allows for benchmarking that\r\nrange from simple defaults to highly customizable options depending on your use case and needs.\r\n\r\n### Enable Benchmarking\r\n\r\nBecause benchmarking negatively impacts performance, we must explicitly tell `ActionLogic` that we want to benchmark (otherwise\r\nit defaults to ignore benchmarking). To do this, we configure `ActionLogic` using the `configure` method. With the provided\r\n`config` object, we explicitly enable benchmarking by setting `config.benchmark = true`:\r\n\r\n```ruby\r\nActionLogic.configure do |config|\r\n  config.benchmark = true\r\nend\r\n```\r\n\r\n### Benchmark Logging\r\n\r\nAdditionally, `ActionLogic` writes a benchmark log to `$stdout` by default, or you can override this default configuration\r\nby specifying a log file. To do this, you configure `ActionLogic` to use a `File` object for logging benchmark results via the\r\n`ActionLogic.configure` method:\r\n\r\n```ruby\r\nActionLogic.configure do |config|\r\n  config.benchmark = true\r\n\tconfig.benchmark_log = File.open(\"benchmark.log\", \"w\")\r\nend\r\n```\r\n\r\n### Benchmark Log Formatting\r\n\r\nBy default, `ActionLogic` formats benchmark logs in the following format:\r\n\r\n```\r\ncontext:ValidateAroundPresenceTestUseCase user_time:0.000000 system_time:0.000000 total_time:0.000000 real_time:0.000135\r\n...\r\n```\r\n\r\nThe default format is intended to be machine readable for easy parsing and is not intended to be used for human reading.\r\nHowever, if you wish to change the format of the log output, `ActionLogic` allows you to override the default formatter by\r\nallowing you to provide your own formatter:\r\n\r\n```ruby\r\nActionLogic.configure do |config|\r\n  config.benchmark = true\r\n\tconfig.benchmark_log = File.open(\"benchmark.log\", \"w\")\r\n\tconfig.benchmark_formatter = YourCustomFormatter\r\nend\r\n```\r\n\r\nWhere `YourCustomFormatter` subclasses `ActionLogic::ActionBenchmark::DefaultFormatter`:\r\n\r\n```ruby\r\nclass CustomFormatter < ActionLogic::ActionBenchmark::DefaultFormatter\r\n\r\n  def log_coordinator(benchmark_result, execution_context_name)\r\n\t\tbenchmark_log.puts(\"The ActionCoordinator #{execution_context_name} took #{benchmark_result.real} to complete.\")\r\n  end\r\n\r\n  def log_use_case(benchmark_result, execution_context_name)\r\n\t\tbenchmark_log.puts(\"The ActionUseCase #{execution_context_name} took #{benchmark_result.real} to complete.\")\r\n  end\r\n\r\n  def log_task(benchmark_result, execution_context_name)\r\n\t\tbenchmark_log.puts(\"The ActionTask #{execution_context_name} took #{benchmark_result.real} to complete.\")\r\n  end\r\n\r\nend\r\n```\r\n\r\nFrom the example above, you can see that a custom formatter is required to define three methods: `log_coordinator`, `log_use_case` and `log_task`. The `log_t cqcoordinator`\r\nmethod is called when a `ActionCoordinator` context is benchmarked. The `use_case` and `task` methods are invoked when `ActionUseCase` and `ActionTask`\r\ncontexts are benchmarked, respectively.\r\n\r\nEach of the three log methods receives two input parameters: `benchmark_result` and `execution_context_name` where `benchmark_result` is a Ruby\r\nstandard library `Benchmark` result object, and `execution_context_name` is the class name of the `ActionLogic` context.\r\n\r\nOnce configured, you can verify that the formatter outputs to the specified log file by executing your `ActionLogic` contexts\r\nand verifying that the log file is written to with the correct format:\r\n\r\n```\r\nThe ActionUseCase TestUseCase2 took 0.00011722202179953456 to complete.\r\nThe ActionTask TestTask3 took 4.570698365569115e-05 to complete.\r\n...\r\n```\r\n\r\n### Custom Benchmark Handling\r\n\r\nBy default, `ActionLogic` benchmarks execution contexts using Ruby's `Benchmark` module. If you are content with a `Benchmark` result object, then\r\nyou do not need to specify a custom benchmark handler. However, if you wish to have maximum control, or you require something different than Ruby's\r\n`Benchmark` module, you can define a custom handler like so:\r\n\r\n```ruby\r\nclass CustomHandler\r\n  def call\r\n    # custom logic\r\n    yield\r\n    # custom logic\r\n  end\r\nend\r\n```\r\n\r\nYour custom handler is free to define any custom logic, but you must yield during the body of the `call` method. This is what triggers the execution\r\ncontext and will allow your custom handler to measure the length of execution. If you do not yield, the relevant `ActionCoordinator`, `ActionUseCase`\r\nor `ActionTask` will not be executed and will result in no execution to benchmark.\r\n\r\nAdditionally, you must register your custom handler with `ActionLogic` using `ActionLogic.configure`:\r\n\r\n```ruby\r\nActionLogic.configure do |config|\r\n  config.benchmark = true\r\n  config.benchmark_log = File.open(\"benchmark.log\", \"w\")\r\n  config.benchmark_handler = CustomHandler.new\r\nend\r\n```\r\n\r\n### Installation\r\n\r\nAdd `ActionLogic` to your project's Gemfile:\r\n\r\n`gem 'action_logic'`\r\n\r\nDon't forget to bundle:\r\n\r\n`$ bundle`\r\n\r\n### Contributing\r\n\r\nInterested in contributing to `ActionLogic`? If so that is awesome! <3\r\nPlease see the [contributing doc](https://github.com/rewinfrey/ActionLogic/blob/master/CONTRIBUTING.md) for details.\r\n","google":"UA-72522466-1","note":"Don't delete this file! It's used internally to help with page regeneration."}